install.packages(c("kernlab", "mlbench", "ggplot2"))
library(kernlab)
library(mlbench)
library(ggplot2)
set.seed(5546)
dataTN <- mlbench.threenorm(100, 2)
dataTN <- data.frame(class=dataTN$classes, dataTN$x)
testdata <- dataTN[1:30,]
Loss <- function(w, y, x ){
levels(y) <- c(-1,1)
y <- as.numeric(y)
L <- c()
for(i in 1:nrow(x)){
m <-  y[i]*(sum(w[2:3]*x[i,])+w[1])
L[i] <- max(0, 1-m)
}
sum(L)
}
marginOpt <- function(w, y, x, C=1){
0.5*sum(w^2)+C*Loss(w,y,x)
}
optim(par=c(1,1,1), fn=marginOpt, y=testdata[,1], x=testdata[,2:3])
optim(par=c(1,1,1), fn=marginOpt, y=dataTN[,1], x=dataTN[,2:3])
marginOpt(c(1,1,1),y=dataTN[,1], x=dataTN[,2:3] )
marginOpt(c(.1,.1,.1),y=dataTN[,1], x=dataTN[,2:3] )
m <- ksvm(class~., data=dataTN[1:30,], kernel="vanilladot", scale=FALSE)
m
coef(m)[[1]] %*% as.matrix(testdata[SVindex(m) ,2:3])
m <- ksvm(class~., data=dataTN[1:30,], kernel="vanilladot", scaled=FALSE)
coef(m)[[1]] %*% as.matrix(testdata[SVindex(m) ,2:3])
HingeLoss <- function(w, y, x ){
levels(y) <- c(-1,1)
y <- as.numeric(y)
loss <- y*(w[2:3]%*%x + w[1])
loss
}
HingeLoss(c(1,1,1), testdata[,2:3], testdata[,1])
testdata
debug(HingeLoss)
testdata
HingeLoss(c(1,1,1), testdata[,2:3], testdata[,1])
HingeLoss(w=c(1,1,1), y=testdata[,2:3], x=testdata[,1])
undebug(HingeLoss)
HingeLoss(w=c(1,1,1), y=testdata[,2:3], x=testdata[,1])
HingeLoss(w=c(1,1,1), x=testdata[,2:3], y=testdata[,1])
HingeLoss <- function(w, y, x ){
levels(y) <- c(-1,1)
y <- as.numeric(y)
x <- as.matrix(x)
loss <- y*(w[2:3]%*%x + w[1])
loss
}
HingeLoss(w=c(1,1,1), x=testdata[,2:3], y=testdata[,1])
library(ggplot2)
library(rpart)
generateDiagData <- function(n=100, ...){
x1 <- sample.int(n,n, replace=T)
x2 <- sample.int(n,n, replace=T)
lab <- x1<x2
x1 <- jitter(x1, ...)
x2 <- jitter(x2, ...)
data.frame(x1,x2,lab)
}
data <- generateDiagData(150, factor=100)
ggplot(data) + geom_point(aes(x=x1, y=x2, color=lab))
tree <- rpart(lab~., data=data)
tree
tree$splits
rect=list(xmin=min(data$x1), xmax=max(data$x1), ymin=min(data$x2), ymax=max(data$x2))
rect
rect=data.frame(xmin=min(data$x1), xmax=max(data$x1), ymin=min(data$x2), ymax=max(data$x2))
rect
tree
str(tree)
tree$frame
tree$splits
colnames(tree$frame)
rownmaes(tree$frame)
rownames(tree$frame)
as.number(rownames(tree$frame))
as.integer(rownames(tree$frame))
order <- as.integer(rownames(tree$frame))
order
tree
tree$splits[order,]
xtfrm(order)
ÃŸo
library(devtools)
library(testthat)
library(roxygen2)
setwd("~/Uni/Fprog/Hausuebung2/")
p1 <- readRDS("trouble/data-trouble1.rds")
p1$x
glm(p1$y ~ p1[,-1], family = binomial)
glm(p1$y ~ p1$x[,-1], family = binomial)
load_all("logitreg3/")
?logitreg
logitreg(p1$x, p1$y)
traceback
summary(p1$x)
which(complete.cases(p1$x))
which(!complete.cases(p1$x))
rows_with_mising_values <- which(!complete.cases(p1$x))
p1$x <- p1$x[-rows_with_mising_values,]
p1$y <- p1$<[-rows_with_mising_values,]
p1$y <- p1$y[-rows_with_mising_values,]
p1$y <- p1$y[-rows_with_mising_values]
str(p1)
logitreg(p1$x, p1$y)
unload("logitreg3/")
create("logtireg4")
roxygenise("logtireg4/")
load_all("logtireg4/")
?logitreg
system.file("data-trouble1.rds", package="logtireg4/")
system.file("testdata/data-trouble1.rds", package="logtireg4/")
system.file("inst/testdata/data-trouble1.rds", package="logtireg4/")
unload("logtireg4/")
load_all("logitreg4/")
system.file("inst/testdata/data-trouble1.rds", package="logitreg4/")
system.file("inst/testdata/data-trouble1.rds", package="logitreg4")
system.file("testdata/data-trouble1.rds", package="logitreg4")
i = 1
assign(paste0("trouble", i),
system.file(paste0("testdata/data-trouble", i, ".rds"),
package="logitreg4"))
assign(paste0("trouble", i),
readRDS(system.file(paste0("testdata/data-trouble", i, ".rds"),
package="logitreg4")))
lapply(1:5, print)
lapply(1:5, function (i) assign(paste0("trouble", i),
readRDS(system.file(paste0("testdata/data-trouble", i, ".rds"),
package="logitreg4"))))
for(i in 1:5){
assign(paste0("trouble", i),
readRDS(system.file(paste0("testdata/data-trouble", i, ".rds"),
package="logitreg4")))
}
complete.cases(trouble1$x)
!complete.cases(trouble1$x)
which(!complete.cases(trouble1$x))
which(!complete.cases(trouble1$y))
2 != 1
! 2== 1
c(1,2,3,4)[-c(1,1,2)]
length(integer(0))
unload("logitreg4/")
load_all("logitreg4/")
logitreg(trouble1$x, trouble1$y)
unload("logitreg4/")
load_all("logitreg4/")
logitreg(trouble1$x, trouble1$y)
logitreg(trouble1$x, trouble1$y)$coefficients
glm(p1$y ~ p1$x[,-1], family = binomial)$coefficients
unname(glm(p1$y ~ p1$x[,-1], family = binomial)$coefficients)
logitreg(trouble1$x, trouble1$y)$coefficients
expect_equal(logitreg(trouble1$x, trouble1$y)$coefficients,
unname(glm(p1$y ~ p1$x[,-1], family = binomial)$coefficients),
tolerance = 0.0009)
str(trouble2)
summary(trouble2$x)
glm(trouble2$y ~ trouble2$x, family = binomial)
table(trouble2$y)
plot(trouble2$y)
logitreg(trouble2$x, trouble1$y)
logitreg(trouble2$x, trouble2$y)
debug(logitreg)
logitreg(trouble2$x, trouble2$y)
optimization_result
optimization_result$convergence
glm(trouble2$y ~ trouble2$x, family = binomial)
load_all("logitreg4/")
logitreg(trouble2$x, trouble2$y)
expect_warning(logitreg(trouble2$x, trouble2$y))
str(trouble3)
glm(trouble3$y ~ trouble3$x, family = binomial)
cor(trouble2$x)
cor(trouble3$x)
summary(trouble3$x)
trouble3$x %*% trouble3$x
t(trouble3$x) %*% trouble3$x
solve(t(trouble3$x) %*% trouble3$x)
glm(trouble3$y ~ trouble3$x, family = binomial)
str(trouble3)
table(trouble3$y)
unique(trouble3$y)
unique(trouble$y)
2
unique(trouble2$y)
setdiff(c(0,1), 1)
load_all("logitreg4/")
logitreg(trouble3$x, trouble3$y)
str(logitreg(trouble3$x, trouble3$y))
expect_warning(logitreg(trouble2$x, trouble2$y,
regex = "Optimizer did not converge, results can be incorrect"))
expect_warning(logitreg(trouble2$x, trouble2$y),
regex = "Optimizer did not converge, results can be incorrect")
expect_warning(logitreg(trouble2$x, trouble2$y))
expect_warning(logitreg(trouble2$x, trouble2$y),
regex = "No observations for class [01] found!")
expect_warning(logitreg(trouble2$x, trouble2$y))
expect_warning(logitreg(trouble3$x, trouble3$y),
regex = "No observations for class 0 found!")
expect_warning(logitreg(trouble3$x, trouble3$y),
regex = "No observations for class [01] found!")
expect_warning(logitreg(trouble2$x, trouble2$y),
regex = "Optimizer did not converge, results can be incorrect")
expect_warning(logitreg(trouble3$x, trouble3$y),
regex = "No observations for class [01] found!")
str(trouble4)
trouble4$x
glm(trouble4$y ~ trouble4$x, family = binomial)
glm(trouble4$y ~ trouble4$x, family = binomial)
source("http://www.statistik.lmu.de/~scheipl/downloads/fortprog/simulate_logitreg.R")
simulate_logitreg(q_factor = 1)
head(simulate_logitreg(q_factor = 1)$x)
summary(simulate_logitreg(q_factor = 1)$x)
summary(simulate_logitreg(q_factor = 2)$x)
logitreg(trouble4$x, trouble4$y)
load_all("logitreg4/")
logitreg(trouble4$x, trouble4$y)
expect_warning(logitreg(trouble4$x, trouble4$y),
regex = "More covariables than observations (p > n), results will be unstable")
load_all("logitreg4/")
expect_warning(logitreg(trouble4$x, trouble4$y),
regex = "More covariables than observations (p > n), results will be unstable")
expect_warning(logitreg(trouble4$x, trouble4$y),
regex = "More covariables than observations (p > n), results will be unstable")
unload("logitreg4/")
load_all("logitreg4/")
expect_warning(logitreg(trouble4$x, trouble4$y),
regex = "More covariables than observations (p > n), results will be unstable")
expect_warning(logitreg(trouble3$x, trouble3$y),
regex = "No observations for class [01] found!")
expect_warning(logitreg(trouble2$x, trouble2$y),
regex = "Optimizer did not converge, results can be incorrect")
str(trouble5)
summary(trouble5$x)
glm(trouble5$y ~ trouble5$x, family = binomial)
logitreg(trouble5$x, trouble5$y)
load_all("logitreg4/")
logitreg(trouble5$x, trouble5$y)
unload("logitreg4/")
load_all("logitreg4/")
logitreg(trouble5$x, trouble5$y)
paste(c(1,2,3), sep =", ")
paste(c(1,2,3), collapse =", ")
load_all("logitreg4/")
logitreg(trouble5$x, trouble5$y)
load_all("logitreg4/")
logitreg(trouble5$x, trouble5$y)
