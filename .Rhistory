install.packages(c("kernlab", "mlbench", "ggplot2"))
library(kernlab)
library(mlbench)
library(ggplot2)
set.seed(5546)
dataTN <- mlbench.threenorm(100, 2)
dataTN <- data.frame(class=dataTN$classes, dataTN$x)
testdata <- dataTN[1:30,]
Loss <- function(w, y, x ){
levels(y) <- c(-1,1)
y <- as.numeric(y)
L <- c()
for(i in 1:nrow(x)){
m <-  y[i]*(sum(w[2:3]*x[i,])+w[1])
L[i] <- max(0, 1-m)
}
sum(L)
}
marginOpt <- function(w, y, x, C=1){
0.5*sum(w^2)+C*Loss(w,y,x)
}
optim(par=c(1,1,1), fn=marginOpt, y=testdata[,1], x=testdata[,2:3])
optim(par=c(1,1,1), fn=marginOpt, y=dataTN[,1], x=dataTN[,2:3])
marginOpt(c(1,1,1),y=dataTN[,1], x=dataTN[,2:3] )
marginOpt(c(.1,.1,.1),y=dataTN[,1], x=dataTN[,2:3] )
m <- ksvm(class~., data=dataTN[1:30,], kernel="vanilladot", scale=FALSE)
m
coef(m)[[1]] %*% as.matrix(testdata[SVindex(m) ,2:3])
m <- ksvm(class~., data=dataTN[1:30,], kernel="vanilladot", scaled=FALSE)
coef(m)[[1]] %*% as.matrix(testdata[SVindex(m) ,2:3])
HingeLoss <- function(w, y, x ){
levels(y) <- c(-1,1)
y <- as.numeric(y)
loss <- y*(w[2:3]%*%x + w[1])
loss
}
HingeLoss(c(1,1,1), testdata[,2:3], testdata[,1])
testdata
debug(HingeLoss)
testdata
HingeLoss(c(1,1,1), testdata[,2:3], testdata[,1])
HingeLoss(w=c(1,1,1), y=testdata[,2:3], x=testdata[,1])
undebug(HingeLoss)
HingeLoss(w=c(1,1,1), y=testdata[,2:3], x=testdata[,1])
HingeLoss(w=c(1,1,1), x=testdata[,2:3], y=testdata[,1])
HingeLoss <- function(w, y, x ){
levels(y) <- c(-1,1)
y <- as.numeric(y)
x <- as.matrix(x)
loss <- y*(w[2:3]%*%x + w[1])
loss
}
HingeLoss(w=c(1,1,1), x=testdata[,2:3], y=testdata[,1])
library(ggplot2)
library(rpart)
generateDiagData <- function(n=100, ...){
x1 <- sample.int(n,n, replace=T)
x2 <- sample.int(n,n, replace=T)
lab <- x1<x2
x1 <- jitter(x1, ...)
x2 <- jitter(x2, ...)
data.frame(x1,x2,lab)
}
data <- generateDiagData(150, factor=100)
ggplot(data) + geom_point(aes(x=x1, y=x2, color=lab))
tree <- rpart(lab~., data=data)
tree
tree$splits
rect=list(xmin=min(data$x1), xmax=max(data$x1), ymin=min(data$x2), ymax=max(data$x2))
rect
rect=data.frame(xmin=min(data$x1), xmax=max(data$x1), ymin=min(data$x2), ymax=max(data$x2))
rect
tree
str(tree)
tree$frame
tree$splits
colnames(tree$frame)
rownmaes(tree$frame)
rownames(tree$frame)
as.number(rownames(tree$frame))
as.integer(rownames(tree$frame))
order <- as.integer(rownames(tree$frame))
order
tree
tree$splits[order,]
xtfrm(order)
ÃŸo
library(devtools)
setwd("~/Uni/Fprog/Hausuebung2/")
check("logitreg1/")
check("logitreg2/")
check("logitreg3/")
cat("/tmp/RtmpPcjuFT/logitreg3.Rcheck/00check.log
")
check("logitreg4/")
load_all("logitreg4/")
test("logitreg4/")
check("logitreg5/")
check("logitreg6/")
check("logitreg6/")
check("logitreg6/")
check("logitreg6/")
library(roxygen2)
roxygenise("logitreg6/")
check("logitreg6/")
check("logitreg6/")
check("logitreg6/")
check("logitreg6/")
check("logitreg6/")
test("logitreg6/")
dat  = simulate_logitreg(data.frame = TRUE)
dat
logitreg(y~., data = dat)
x <- logitreg(y~., data = dat)
plot(x)
check("logitreg1/")
check("logitreg2/")
check("logitreg3/")
check("logitreg3/")
check("logitreg3/")
check("logitreg4/")
roxygenise("logitreg4/")
check("logitreg4/")
setwd("~/Uni/Fprog/Hausuebung2/logitreg4")
load_all()
for(i in 1:5){
assign(paste0("trouble", i),
readRDS(system.file(paste0("testdata/data-trouble", i, ".rds"),
package="logitreg4")))
}
expect_equal(logitreg(trouble1$x, trouble1$y)$coefficients,
unname(glm(trouble1$y ~ trouble1$x[,-1], family = binomial)$coefficients),
tolerance = 0.0009)
expect_warning(logitreg(trouble2$x, trouble2$y),
regex = "Optimizer did not converge, results can be incorrect")
trouble2
logitreg(trouble2$x, trouble2$y)
glm(trouble2$y ~ trouble2$x[,-1], family = binomial)
logitreg(trouble2$x, trouble2$y)$coefficients
unload()
logitreg(data$x, data$y, method = "Nelder-Mead"
control = list(ndeps = 1e-2)
logitreg(data$x, data$y, method = "Nelder-Mead")
logitreg(data$x, data$y)
library(testthat)
source("http://www.statistik.lmu.de/~scheipl/downloads/fortprog/simulate_logitreg.R")
data <- simulate_logitreg(seed = 1337)
logitreg(data$x, data$y)
logitreg(data$x, data$y, method = "Nelder-Mead")
logitreg(data$x, data$y, method = "CG")
logitreg(data$x, data$y, method = "SANN")
test("../logitreg3/")
test("../logitreg3/")
unload()
unload("../logitreg3/")
setwd("~/Uni/Fprog/Hausuebung2")
load_all("logitreg4/")
for(i in 1:5){
assign(paste0("trouble", i),
readRDS(system.file(paste0("testdata/data-trouble", i, ".rds"),
package="logitreg4")))
}
expect_equal(logitreg(trouble1$x, trouble1$y)$coefficients,
unname(glm(trouble1$y ~ trouble1$x[,-1], family = binomial)$coefficients),
tolerance = 0.0009)
logitreg(trouble2$x, trouble2$y)
debug(logitreg)
logitreg(trouble2$x, trouble2$y)
response
design
optim(par = initial_coefficients, fn = neg_loglik,
gr = neg_loglik_deriv, response = response,
design = design, method = method, ...)
C
undebug(logitreg)
logitreg(trouble2$x, trouble2$y)
glm(trouble2$y ~ trouble2$x[,-1], family = binomial)
logitreg(trouble2$x, trouble2$y)$fitted
logitreg(trouble2$x, trouble2$y)$fitted == 1
equals(logitreg(trouble2$x, trouble2$y)$fitted)
equals(logitreg(trouble2$x, trouble2$y)$fitted, 1)
x <- logitreg(trouble2$x, trouble2$y)$fitted
x
all.equal(x, 1)
all.equal(x[50], 1)
sapply(x, function(y) equal(y, 1) )
sapply(x, function(y) equals(y, 1) )
sapply(x, function(y) all.equal(y, 1) )
all.equal.numeric(x, 1)
all.equal.numeric(x[1], 1)
check("logitreg4/")
x
lapply(x, function(y) all.equal(y, 1))
is.true(lapply(x, function(y) all.equal(y, 1)))
lapply(x, function(y) all.equal(y, 1)) == TRUE
check_for_1_0 <- function(fitted_values){
lapply(x, function(y) as.logical(all.equal(y, 1))) == TRUE
}
lapply(x, function(y) as.logical(all.equal(y, 1))) == TRUE
glm(trouble2$y ~ trouble2$x[,-1], family = binomial)
logitreg(trouble2$x, trouble2$y)
load_all("logitreg4/")
load_all("logitreg4/")
load_all("logitreg4/")
logitreg(trouble2$x, trouble2$y)
isTRUE(all.equal(x, 1))
any(all.equal(x, 1))
x[1]
x[1] == 0
identical(x[1], 0)
identical(x[50], 1)
all.equal(x[50], 1)
lapply(x , all.equal, current = 1)
any(lapply(x , all.equal, current = 1))
any(unlist(lapply(x , all.equal, current = 1)))
(unlist(lapply(x , all.equal, current = 1))
)
any(as.logical(unlist(lapply(x , all.equal, current = 1))))
any(as.logical(unlist(lapply(x , all.equal, current = 0))))
load_all("logitreg4/")
logitreg(trouble2$x, trouble2$y)
load_all("logitreg4/")
logitreg(trouble2$x, trouble2$y)
load_all("logitreg4/")
test()
tests()
test("logitreg4/")
expect_equal(logitreg(trouble1$x, trouble1$y)$coefficients,
unname(glm(trouble1$y ~ trouble1$x[,-1], family = binomial)$coefficients),
tolerance = 0.0009)
expect_warning(logitreg(trouble2$x, trouble2$y),
regex = "fitted values of numerically 1 or 0 occured")
expect_warning(logitreg(trouble3$x, trouble3$y),
regex = "No observations for class [01] found!")
expect_warning(logitreg(trouble4$x, trouble4$y))
logitreg(trouble4$x, trouble4$y)
expect_warning(logitreg(trouble4$x, trouble4$y),
regex = "More covariables than observations (p > n), results will be unstable")
logitreg(trouble5$x, trouble5$y)
test("logitreg4/")
check("logitreg4/")
roxygenise("logitreg4/")
roxygenise("logitreg4/")
check("logitreg4/")
logitreg(trouble1$x, trouble1$y)
logitreg(trouble1$x, trouble1$y)$fitted
fitted <- logitreg(trouble1$x, trouble1$y)$fitted
any(as.logical(unlist(lapply(fitted , all.equal, current = 0))))
any(as.logical(unlist(lapply(fitted , all.equal, current = 1)))))
any(as.logical(unlist(lapply(fitted , all.equal, current = 1))))
load_all("logitreg4/")
any(as.logical(unlist(lapply(fitted , all.equal, current = 1))))
any(as.logical(unlist(lapply(fitted , all.equal, current = 1, na.rm = TRUE))))
load_all("logitreg4/")
x
x - 1 < .Machine$double.eps
x
x < .Machine$double.eps
x > .Machine$double.eps +1
.Machine$double.eps +1
abs(x - 1) > .Machine$double.eps
abs(x - 1) < .Machine$double.eps
abs(x - 1)
.Machine$double.eps
x <= .Machine$double.eps
abs(x - 1) <= .Machine$double.eps
(x <= .Machine$double.eps | abs(x - 1) <= .Machine$double.eps)
any(x <= .Machine$double.eps | abs(x - 1) <= .Machine$double.eps)
load_all("logitreg4/")
logitreg(trouble1$x, trouble1$y)
logitreg(trouble2$x, trouble2$y)
test("logitreg4/")
